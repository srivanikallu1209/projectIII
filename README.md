1. The Operational Context: "Eventual Consistency"In a social media app, speed is more important than absolute data synchronization.Scenario: When a user clicks "Post," the Post Service saves it to the database immediately. However, the followers don't need to see the notification at that exact microsecond.Context: We use RabbitMQ to achieve Eventual Consistency. The Post Service "fires and forgets" an event, and the Notification Service picks it up when it's ready.
2. 2. The Architectural Context: The "Sidecar" and RegistryBecause you have 6+ services, they cannot have hardcoded URLs (like localhost:8081).Eureka (Discovery): Think of this as the "GPS" of your project. Every service registers its location here.API Gateway: This is the "Bouncer." The React frontend only talks to the Gateway (Port 8080). The Gateway then asks Eureka, "Where is the Post Service?" and routes the traffic.
   3. 3. The Data Context: Polyglot PersistenceEach module (service) owns its own data. This is crucial for microservices.Post Service: Uses PostgreSQL because posts are relational (linked to Users).Chat Service: Uses MongoDB or Cassandra because chat messages are high-volume and unstructured.Media Service: Doesn't store files in the DB; it stores them in Object Storage (S3/MinIO) and only keeps the "URL" in the database.
      4. 4. The Technical Stack ContextThis project bridges the gap between the Request/Response world and the Stream world.LayerTechnologyContextual RoleFrontendReact (Context API)Provides a reactive, real-time UI that doesn't refresh the page.RoutingSpring Cloud GatewayHandles Load Balancing and Security (JWT).CommunicationOpenFeign / RabbitMQOpenFeign for synchronous calls; RabbitMQ for async events.ResilienceResilience4jPrevents one slow service (e.g., Media) from crashing the whole app.
3. 5. Why Docker Matters HereIn this project, the Docker Context is what makes local development possible. Without Docker, you would have to manually install PostgreSQL, MongoDB, RabbitMQ, and Zipkin on your machine.The docker-compose.yml creates a Virtual Network where services can call each other by their container names (e.g., http://post-service:8081).
